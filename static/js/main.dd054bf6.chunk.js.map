{"version":3,"sources":["Sequence.ts","components/Canvas.tsx","ViewerScreen.tsx","App.tsx","index.tsx"],"names":["Sequence","nextIndex","screenList","updatePeriod","nullCount","intervalTimer","screenListUrl","start","a","getScreenList","update","setInterval","axios","get","response","data","screens","console","log","now","Date","getTime","forEach","screen","resource","nextUpdate","url","method","responseType","result","status","image","imageString","Buffer","from","toString","type","charAt","Image","onload","onerror","error","imgStr","src","refreshMinutes","this","getNext","item","displaySecs","length","JSON","parse","dateFormat","require","MyCanvas","props","currentImage","componentDidUpdate","prevProps","showImage","newImage","name","canvas","document","getElementById","width","window","innerWidth","height","innerHeight","ctx","getContext","wrh","newWidth","newHeight","x","y","fadeOutImage","clearRect","fadeInImage","fillStyle","fillRect","font","fillText","w","h","Promise","resolve","reject","opacity","fade","globalAlpha","drawImage","requestAnimationFrame","id","React","Component","Viewer","sequence","timeout","showNextScreen","nextItem","setState","displayTime","setTimeout","state","handleClick","event","button","isInFullScreen","openFullscreen","closeFullscreen","fullscreenElement","docElm","documentElement","dir","requestFullscreen","exitFullscreen","clearTimeout","className","App","publicUrlPrefix","ViewerScreen","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.dd054bf6.chunk.js","sourcesContent":["import axios from 'axios';\r\n\r\nexport interface Screen {\r\n    nextUpdate: number;\r\n    resource: string;\r\n    displaySecs: number;\r\n    refreshMinutes: number;\r\n    image: any | null;\r\n}\r\n\r\nexport class Sequence {\r\n    nextIndex: number;\r\n    screenList: Array<Screen>;\r\n    updatePeriod: number;\r\n    nullCount: number;\r\n    intervalTimer: any;\r\n    screenListUrl = \"http://glimmerhub.com/config/screen-list.json\"\r\n\r\n    constructor() {\r\n        this.nextIndex = 0;\r\n        this.screenList = [];\r\n        this.updatePeriod = 60;\r\n        this.nullCount = 0;\r\n\r\n        this.screenList = JSON.parse('{\"screens\" : [{\"resource\": \"https://i.imgur.com/Whf10Sd.png\", \"refreshMinutes\": 60, \"displaySecs\": 6}]}');\r\n    }\r\n\r\n    start = async () => {\r\n        await this.getScreenList();\r\n\r\n        this.update(); // Do it once now.\r\n        \r\n        this.intervalTimer = setInterval(this.update, 60*1000);\r\n    }\r\n\r\n    getScreenList = async () => {\r\n        try {\r\n            const response = await axios.get(this.screenListUrl);\r\n            this.screenList = response.data.screens as Array<Screen>;\r\n\r\n        } catch (e) {\r\n            console.log(`Sequence::getScreenList failed to get data ${e}`);\r\n        }\r\n    }\r\n\r\n    update = async () => {\r\n        console.log(`Sequence::update - **********************  Starting  *********************`);\r\n        const now = new Date().getTime();\r\n        //for (const screen of this.screenList) {\r\n        this.screenList.forEach(async (screen) => {\r\n            console.log(`Sequence::update: Checking: ${screen.resource}`);\r\n            if (typeof screen.nextUpdate === 'undefined' || screen.nextUpdate < now) {\r\n                console.log(`Sequence::update: Time to update: ${screen.resource}`);\r\n                let result = await axios({\r\n                    url: screen.resource,\r\n                    method: \"get\",\r\n                    responseType: \"arraybuffer\"\r\n                })\r\n\r\n                console.log(`Sequence::update: ${screen.resource} GET status: ${result.status}`);\r\n\r\n                if (result.status !== 200) {\r\n                    screen.image = null;\r\n                } else {\r\n                    const imageString = Buffer.from(result.data, 'binary').toString('base64');\r\n\r\n                    let type;\r\n                    if (imageString.charAt(0) === '/') {\r\n                        type = \"jpeg\";\r\n                    } else if (imageString.charAt(0) === 'i') {\r\n                        type = \"png\";\r\n                    } else if (imageString.charAt(0) === 'R') {\r\n                        type = \"gif\";\r\n                    } else if (imageString.charAt(0) === 'U') {\r\n                        type = \"webp\";\r\n                    } else {\r\n                        type = \"\";\r\n                    }\r\n\r\n                    // console.log(`Sequence::update: ${screen.resource} type is ${type}`);\r\n                    let image = new Image();\r\n\r\n                    image.onload = () => {\r\n                        console.log(`Sequence::update: ${screen.resource} image.onload`);\r\n                        screen.image = image;\r\n                        // console.dir(image);\r\n                        // this.showImage(image); - we will do this in Canvas\r\n                    }\r\n\r\n                    image.onerror = () => {\r\n                        console.error(`Sequence::update: ${screen.resource} image.onerror`);\r\n                        screen.image = null;\r\n                    }\r\n\r\n                    // console.log(`Sequence::update: ${screen.resource} type is ${type} again`);\r\n                    const imgStr = \"data:image/\" + type + \";base64,\" + imageString;\r\n                    // console.log(`Sequence::update Assigning data to image: ${imgStr}`);\r\n                    image.src = imgStr;\r\n\r\n                    screen.nextUpdate = now + (screen.refreshMinutes * 3600);\r\n                    console.log(`Sequence::update Updated next update to ${screen.nextUpdate}`);\r\n                    console.log(`Sequence::update (update-time - now)/60 seconds ${(screen.nextUpdate - now)/60}`);\r\n                }\r\n            } else {\r\n                console.log(`Sequence::update: ${screen.resource} up-to-date`)\r\n            }\r\n        \r\n        });\r\n    }\r\n   \r\n\r\n    // TODO: should this just return an image?\r\n    getNext = (): Screen => {\r\n        let item: Screen = this.screenList[this.nextIndex] as Screen;\r\n\r\n        if (item.image === null && this.nullCount < 2) {\r\n            // Don't advance the index on a null image the first 2 times\r\n            this.nullCount++\r\n        } else {\r\n            this.nextIndex++\r\n        }\r\n\r\n        if (item.image === null ) {\r\n            console.log(`Sequence::getNext: returning null image with 1 sec duration`)\r\n            const nullImage:Screen = {image: null, displaySecs: 5, nextUpdate: 0, refreshMinutes: 0, resource: \"\"};\r\n            return nullImage;\r\n        }\r\n\r\n        if (this.nextIndex >= this.screenList.length)\r\n            this.nextIndex = 0;\r\n\r\n        console.log(`Sequence::getNext: resource: ${item.resource} non-null\"}`)\r\n        return item;\r\n    }\r\n\r\n}","import React from 'react';\r\nvar dateFormat = require(\"dateformat\");\r\n\r\nexport interface MyCanvasProps {\r\n    name: string;\r\n    image: HTMLImageElement | null;\r\n}\r\n\r\nexport class MyCanvas extends React.Component {\r\n    // Important props:\r\n    // screen - Object with:\r\n    //    image - image data to use directly in assignment to image.src\r\n    //    displaySecs - how long this screen should be displayed for\r\n    // eslint-disable-next-line no-useless-constructor\r\n    currentImage: HTMLImageElement | null;\r\n    props: MyCanvasProps;\r\n\r\n    constructor(props: MyCanvasProps) {\r\n        super(props);\r\n        this.props = props;\r\n        this.currentImage = null;\r\n    }\r\n\r\n    componentDidUpdate = (prevProps: MyCanvasProps) => {\r\n        //console.log(`Canvas::componentDidUpdate- show the image`);\r\n        this.showImage(this.props.image);\r\n    }\r\n\r\n    componentDidMount() {\r\n        //console.log(`Canvas::componentDidMount- show the image`);\r\n        this.showImage(this.props.image);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        // console.log(`Canvas - componentWillUnmount: ${this.props.url}`);\r\n    }\r\n\r\n    fadeInImage(ctx: CanvasRenderingContext2D, image: HTMLImageElement, x: number, y: number, w: number, h: number) {\r\n        return new Promise<void>(function (resolve, reject) {\r\n            console.log(\"fadeInImage start\")\r\n            let opacity = 0;\r\n            function fade() {\r\n                if ((opacity += .05) < 1) {\r\n                    //console.dir(ctx);\r\n                    //console.dir(image);\r\n                    //console.log(`Opacity: ${opacity}`);\r\n                    ctx.globalAlpha = opacity;\r\n                    ctx.drawImage(image, x, y, w, h);\r\n                    //ctx.fillStyle = \"rgba(255, 255, 255, opacity)\";\r\n                    //el.style.opacity = opacity;\r\n                    requestAnimationFrame(fade);\r\n                } else {\r\n                    console.log(\"fadeInImage done\");\r\n                    resolve();\r\n                }\r\n            }\r\n            fade();\r\n        });\r\n    };\r\n\r\n    fadeOutImage(ctx: CanvasRenderingContext2D, image: HTMLImageElement, x: number, y: number, w: number, h: number) {\r\n        return new Promise<void>(function (resolve, reject) {\r\n            console.log(\"fadeOutImage start\")\r\n            let opacity = 1;\r\n            function fade() {\r\n                if ((opacity -= .05) > 0) {\r\n                    //console.dir(ctx);\r\n                    //console.dir(image);\r\n                    //console.log(`Opacity: ${opacity}`);\r\n                    ctx.globalAlpha = opacity;\r\n                    ctx.drawImage(image, x, y, w, h);\r\n                    //ctx.fillStyle = \"rgba(255, 255, 255, opacity)\";\r\n                    //el.style.opacity = opacity;\r\n                    requestAnimationFrame(fade);\r\n                } else {\r\n                    console.log(\"fadeOutImage done\");\r\n                    resolve();\r\n                }\r\n            }\r\n            fade();\r\n        });\r\n    };\r\n\r\n    showImage = async (newImage: HTMLImageElement | null) => {\r\n        if (typeof newImage !== 'undefined' && newImage !== null) {\r\n            console.log(`Canvas::showImage showing image (${this.props.name}).`);\r\n            //console.dir(newImage);\r\n            let canvas: HTMLCanvasElement | null = document.getElementById(\"myCanvas\") as HTMLCanvasElement;\r\n            if (canvas === null) {\r\n                console.log(\"Canvas:: showImage() - \\\"myCanvas\\\" element was null\");\r\n                return;\r\n            }\r\n            canvas.width = window.innerWidth;\r\n            canvas.height = window.innerHeight;\r\n\r\n            let ctx: CanvasRenderingContext2D | null = canvas.getContext(\"2d\");\r\n\r\n            if (ctx === null) {\r\n                console.log(\"Canvas:: showImage() - Failed to get CanvasRenderingContext2D from canvas\");\r\n                return;\r\n            }\r\n\r\n            var wrh = newImage.width / newImage.height;\r\n            var newWidth = canvas.width;\r\n            var newHeight = newWidth / wrh;\r\n            if (newHeight > canvas.height) {\r\n                newHeight = canvas.height;\r\n                newWidth = newHeight * wrh;\r\n            }\r\n\r\n            var x = 0;\r\n            var y = 0;\r\n\r\n            if (newWidth < canvas.width) {\r\n                x = (canvas.width - newWidth) / 2;\r\n            }\r\n\r\n            if (newHeight < canvas.height) {\r\n                y = (canvas.height - newHeight) / 2;\r\n            }\r\n\r\n            console.log(\"before\");\r\n            if (this.currentImage !== null) {\r\n                await this.fadeOutImage(ctx, this.currentImage, x, y, newWidth, newHeight);\r\n            }\r\n            //await this.fadeToBlack(ctx, canvas.width, canvas.height);\r\n            console.log(\"middle\");\r\n            \r\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n            //ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n            //ctx.drawImage(newImage, x, y, newWidth, newHeight);\r\n            await this.fadeInImage(ctx, newImage, x, y, newWidth, newHeight);\r\n            \r\n            console.log(\"end\");\r\n\r\n            this.currentImage = newImage; //{image: newImage, x: x, y: y, w: newWidth, h: newHeight};\r\n            \r\n        } else {\r\n            console.log(`Canvas::showImage is null or undefined, user sees the time.`);\r\n            let canvas: HTMLCanvasElement = document.getElementById(\"myCanvas\") as HTMLCanvasElement;\r\n            canvas.width = window.innerWidth;\r\n            canvas.height = window.innerHeight;\r\n\r\n            let ctx: CanvasRenderingContext2D | null = canvas.getContext(\"2d\");\r\n\r\n            if (ctx === null) {\r\n                console.log(\"Canvas:: showImage() - Failed to get CanvasRenderingContext2D from canvas\");\r\n                return;\r\n            }\r\n\r\n            ctx.fillStyle = \"#003399\";\r\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n            const now = new Date();\r\n            // Canvas Handbook: https://bucephalus.org/text/CanvasHandbook/CanvasHandbook.html\r\n            // Upper left is 0,0\r\n\r\n            ctx.fillStyle = 'red';\r\n            ctx.font = '80pt Arial bold';\r\n            ctx.fillText(dateFormat(now, \"h:MM TT\"),\r\n                canvas.width / 2 - 300, canvas.height / 2);\r\n            // ctx.fillText (dateFormat(now, \"dddd, mmm dS, yyyy\"),\r\n            //                 canvas.width/2 - 100,canvas.height/2 -50);        \r\n        }\r\n    }\r\n\r\n    render(): React.ReactNode {\r\n        console.log(\"MyCanvas::render\");\r\n        return (<canvas id=\"myCanvas\"></canvas>);\r\n    }\r\n}","import React from 'react';\r\n\r\nimport './App.css';\r\nimport { MyCanvas } from './components/Canvas';\r\n\r\nimport { Sequence, Screen } from \"./Sequence\";\r\n//import Screen from \"./Sequence\";\r\n\r\ninterface ViewerProps {\r\n}\r\n\r\ninterface ViewerState {\r\n    image: any | null;\r\n    name: string;\r\n    displayTime: number;\r\n}\r\n\r\nclass Viewer extends React.Component<ViewerProps, ViewerState> {\r\n    \r\n    sequence: Sequence;\r\n    timeout: any | null;\r\n\r\n    constructor(props: ViewerProps) {\r\n        super(props);\r\n        \r\n        this.sequence = new Sequence();\r\n        this.state = {\r\n            image:     null,\r\n            name: \"null\",\r\n            displayTime: 0\r\n        };\r\n\r\n        this.timeout = null;\r\n    }\r\n\r\n    showNextScreen = (): void => {\r\n        console.log(\"ViewerScreen::showNextScreen\");\r\n        let nextItem: Screen = this.sequence.getNext();\r\n\r\n        this.setState({\r\n            image: nextItem.image,\r\n            name: nextItem.resource,\r\n            displayTime: nextItem.displaySecs            \r\n        });\r\n\r\n        this.timeout = setTimeout(() => {\r\n            console.log(`ViewerScreen::showNextScreen - setting timeout for ${this.state.displayTime} secs`);\r\n            this.showNextScreen();\r\n        }, this.state.displayTime * 1000)\r\n    }\r\n\r\n    async componentDidMount() {  \r\n        await this.sequence.start();\r\n              \r\n        this.showNextScreen();\r\n\r\n        //document.addEventListener('mousedown', this.handleClick);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        if (this.timeout !== null) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = null;\r\n        }\r\n    }\r\n\r\n    // This is the handler for the mouse buttons.  In full screen it can be used to \r\n    // advance, rewind or logout  \r\n    handleClick = (event: React.MouseEvent) => {\r\n        console.log(\"Viewer::onClick\", event.button);\r\n        \r\n        if (this.isInFullScreen()) {\r\n            this.openFullscreen();\r\n        } else {\r\n            this.closeFullscreen();\r\n        }\r\n    }\r\n\r\n    isInFullScreen = () => {\r\n        return (document.fullscreenElement && document.fullscreenElement !== null);\r\n         \r\n        // return (document.fullscreenElement && document.fullscreenElement !== null) ||\r\n        //     (document.webkitFullscreenElement && document.webkitFullscreenElement !== null) ||\r\n        //     (document.mozFullScreenElement && document.mozFullScreenElement !== null) ||\r\n        //     (document.msFullscreenElement && document.msFullscreenElement !== null)\r\n    }\r\n\r\n    openFullscreen = () => {\r\n        //console.log(\"openFullScreen\");\r\n        var docElm = document.documentElement;\r\n        console.dir(docElm);\r\n\r\n        if (docElm.requestFullscreen) {\r\n            docElm.requestFullscreen();\r\n        // } else if (docElm.mozRequestFullScreen) {\r\n        //     docElm.mozRequestFullScreen();\r\n        // } else if (docElm.webkitRequestFullScreen) {\r\n        //     docElm.webkitRequestFullScreen();\r\n        // } else if (docElm.msRequestFullscreen) {\r\n        //     docElm.msRequestFullscreen();\r\n        }\r\n    }\r\n\r\n    /* Close fullscreen */\r\n    closeFullscreen = () => {\r\n        //console.log(\"closeFullScreen\");\r\n        if (document.exitFullscreen) {\r\n            document.exitFullscreen();\r\n        // } else if (document.webkitExitFullscreen) {\r\n        //     document.webkitExitFullscreen();\r\n        // } else if (document.mozCancelFullScreen) {\r\n        //     document.mozCancelFullScreen();\r\n        // } else if (document.msExitFullscreen) {\r\n        //     document.msExitFullscreen();\r\n        }\r\n    }\r\n\r\n    render() {\r\n        console.log(\"Viewer::render\");\r\n        return (\r\n            <div id=\"myViewer\" className=\"Viewer\">\r\n                <MyCanvas image ={this.state.image} name = {this.state.name}/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Viewer;","import React, { ReactNode } from 'react';\nimport './App.css';\n\nimport ViewerScreen from \"./ViewerScreen\"\n\ninterface AppProps {\n}\n\nclass App extends React.Component {\n\n    constructor(props: AppProps) {\n        super(props);\n        //this.sequence = new Sequence(\"url\");\n\n        this.state = {\n            publicUrlPrefix: \"\",\n        };\n    }\n\n    render(): ReactNode {\n        // console.log(`App::render - PUBLIC_URL=${this.state.publicUrlPrefix}`)\n\n        return (\n            <div>\n                \n                    <ViewerScreen />\n                \n            </div>\n        )\n    }\n}\n\nexport default App;","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n//import { BrowserRouter as Router } from 'react-router-dom';\r\n// import './index.css';\r\nimport App from './App';\r\n//import * as serviceWorker from './serviceWorker';\r\n\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\n\r\n//ReactDOM.render( < App / > , document.getElementById('root'));\r\n\r\n// ReactDOM.render(\r\n//     <Router>\r\n//         < App />\r\n//     </Router>, \r\n//     document.getElementById('root')\r\n// );\r\n\r\nReactDOM.render(\r\n    <React.StrictMode>\r\n      <App />\r\n    </React.StrictMode>,\r\n    document.getElementById('root')\r\n  );\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\n//serviceWorker.unregister(); "],"sourceRoot":""}